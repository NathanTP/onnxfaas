import pathlib

ferPath = pathlib.Path("../data/emotion_ferplus")
ferModelPath = ferPath / "model.onnx"


# This is done weird for profiling purposes so I can measure the time
# contribution of imports
def imports():
    for m in ['onnxruntime', 'onnx']:
        globals()[m] = __import__(m)

    globals()['np'] = __import__("numpy")
    import onnx.numpy_helper


def initFer(profile=False, provider="CUDAExecutionProvider"):
    opts = onnxruntime.SessionOptions()
    # opts.optimized_model_filepath = "optModel.onnx"

    opts.enable_profiling = profile 

    # ferModelPath="./optModel.onnx"
    ferSession = onnxruntime.InferenceSession(
            str(ferModelPath),
            sess_options=opts,
            providers=[provider])

    return {
            "session" : ferSession,
            "inputName" : ferSession.get_inputs()[0].name,
            "outputName" : ferSession.get_outputs()[0].name,
        }


def emotion_map(classes, N=1):
    """Take the most probable labels (output of postprocess) and returns the 
    top N emotional labels that fit the picture."""

    emotion_table = {'neutral':0, 'happiness':1, 'surprise':2, 'sadness':3, 
                     'anger':4, 'disgust':5, 'fear':6, 'contempt':7}

    emotion_keys = list(emotion_table.keys())
    emotions = []
    for i in range(N):
        emotions.append(emotion_keys[classes[i]])
    return emotions


def softmax(x):
    """Compute softmax values (probabilities from 0 to 1) for each possible label."""
    x = x.reshape(-1)
    e_x = np.exp(x - np.max(x))
    return e_x / e_x.sum(axis=0)


def toClassIds(scores):
    """This function takes the scores generated by the network and 
    returns the class IDs in decreasing order of probability."""
    prob = softmax(scores)
    prob = np.squeeze(prob)
    classes = np.argsort(prob)[::-1]
    return classes


def preProcess(datString):
    tensor = onnx.TensorProto()
    tensor.ParseFromString(datString)

    npDat = onnx.numpy_helper.to_array(tensor)
    return npDat 


def postProcess(onnxRes):
    return emotion_map(toClassIds(onnxRes[0]))


def runModel(state, data):
    return state['session'].run([state['outputName']], {state['inputName'] : data})


def getInputs():
    # Load a test image (we'll just use the same image over and over for simplicity)
    with open(ferPath / 'test_data_set_0' / 'input_0.pb', 'rb') as f:
        inStr = f.read()

    return [inStr]

class interface:
    imports = imports
    init = initFer
    pre = preProcess
    run = runModel
    post = postProcess
    inputs = getInputs
